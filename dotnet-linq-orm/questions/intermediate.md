# Intermediate Level Questions

## Table of Contents

### LINQ

<details>
<summary>1. What are the differences between LINQ and stored procedure?</summary>

>#### Answer:
>* Stored procedures are much faster than a LINQ query as they follow an expected execution plan.
>* It is easy to avoid run-time errors while executing a LINQ query than in comparison to a stored procedure as the former has Visual Studio’s Intellisense support as well as full-type checking during compile-time.
>* LINQ allows debugging by making use of .NET debugger which is not in case of stored procedures.
>* LINQ offers support for multiple databases in contrast to stored procedures, where it is essential to re-write the code for diverse types of databases.
>* Deployment of LINQ based solution is easy and simple in comparison to deployment of a set of stored procedures.

</details>

<details>
<summary>2. Why LINQ is good to use? Count Advantages.</summary>

>#### Answer:
>* LINQ offers syntax highlighting that proves helpful to find out mistakes during design time.
>* LINQ offers IntelliSense which means writing more accurate queries easily.
>* Writing codes is quite faster in LINQ and thus development time also gets reduced significantly.
>* LINQ makes easy debugging due to its integration in the C# language.
>* Viewing relationship between two tables is easy with LINQ due to its hierarchical feature and this enables composing queries joining multiple tables in less time.
>* LINQ allows usage of a single LINQ syntax while querying many diverse data sources and this is mainly because of its unitive foundation.
>* LINQ is extensible that means it is possible to use knowledge of LINQ to querying new data source types.
>* LINQ offers the facility of joining several data sources in a single query as well as breaking complex problems into a set of short queries easy to debug.
>* LINQ offers easy transformation for conversion of one data type to another like transforming SQL data to XML data.

</details>

<details>
<summary>3. What are Anonymous Types? Do they useful in LINQ? Why?</summary>

>#### Answer:
> Anonymous types are types that are generated by compiler at run time. When we create a anonymous type we do not specify a name. We just write properties names and their values. Compiler at runtime create these properties and assign values to them.
```csharp
var longwords = from w in words where w.length > 10;
Dim longwords = from w in words where w.length > 10
```
> Anonymous class is useful in LINQ queries to save our intermediate results.

</details>

<details>
<summary>4. What is the difference between First() and Take(1)?</summary>

>**Source Code:**
```csharp
var result = List.Where(x => x == "foo").First();
var result = List.Where(x => x == "foo").Take(1);
```

>#### Answer:
> The difference between `First()` and `Take()` is that `First()` returns the element itself, while `Take(1)` returns a sequence of elements that contains exactly one element.

</details>

<details>
<summary>5. Check the provided code. Are the expressions doing the same? What <code>res1</code> and <code>res2</code> variables will contain after execution?</summary>

>**Source Code:**
```csharp
var data = new List<int> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
var res1 = data.Skip(2).Take(2).ToList();
var res2 = data.Take(2).Skip(2).ToList();
```

>#### Answer:
> **res1** will contain {3, 4}. **res2** will be empty collection.

</details>

<details>
<summary>6. What is the difference between <code>IEnumerable</code> and <code>IQuerable</code>? How may it affect performance of the request?</summary>

>#### Answer:
>`IQueryable<T>` extends the `IEnumerable<T>` interface, so anything you can do with a "plain" `IEnumerable<T>`, you can also do with an `IQueryable<T>`. `IEnumerable<T>` just has a `GetEnumerator()` method that returns an `Enumerator<T>` for which you can call its `MoveNext()` method to iterate through a sequence of T. IQueryable<T> has two properties in particular—one that points to a query provider and another one pointing to a query expression representing the `IQueryable<T>` object as a runtime-traversable abstract syntax tree that can be understood by the given query provider.
>
>When you write queries with `IEnumerable` it executes queries on Server and load data in memory and then filter data on client side. This will be a problem when you are fetching large amount of data. While `IQueryable` executes queries on server side with all filters and then load all data into memory. 

</details>

### Database modelling with Code First (EF Core)

<details>
<summary>1. What is Shadow properties and why they might be useful?</summary>

>#### Answer:
>Shadow properties are properties that are not defined in your .NET entity class but are defined for that entity type in the EF Core model. The value and state of these properties is maintained purely in the Change Tracker. Shadow properties are useful when there is data in the database that should not be exposed on the mapped entity types.

</details>

<details>
<summary>2. I want to Configure Shadow properties. How can I reach this?</summary>

>#### Answer:
>You can use the Fluent API to configure Shadow properties. Once you have called the string overload of Property, you can chain any of the configuration calls you would for other properties. In the following sample, since Blog has no CLR property named LastUpdated, a Shadow property is created:

```csharp
class MyContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Blog>()
            .Property<DateTime>("LastUpdated");
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
}
```

>If the name supplied to the Property method matches the name of an existing property (a shadow property or one defined on the entity class), then the code will configure that existing property rather than introducing a new shadow property.

</details>

<details>
<summary>3. How can I access Shadow properties? (Get/Update)</summary>

>#### Answer:

```csharp
class MyContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Blog>()
            .Property<DateTime>("LastUpdated");
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
}
```

>Shadow property values can be obtained and changed through the ChangeTracker API:
```csharp
context.Entry(myBlog).Property("LastUpdated").CurrentValue = DateTime.Now;
```

>Shadow properties can be referenced in LINQ queries via the EF.Property static method:
```csharp
var blogs = context.Blogs
    .OrderBy(b => EF.Property<DateTime>(b, "LastUpdated"));
```

</details>

<details>
<summary>4. How can we override Entity Framework Core's default behaviour (conventions) and configure entities and their properties and relationships to a relational database?</summary>

>#### Answer:
>Configuration can be applied in two ways:
>
>1) Through decorating classes and properties with Data annotations attributes;
>
>2) By using the Fluent API.
>
</details>

<details>
<summary>5. What is the precedence between <code>Data annotations</code>, <code>Fluent API</code> and <code>Default conventions</code> in EF Core?</summary>

>#### Answer:
>Data annotations and the fluent API can be used together, but precedence of Fluent API > Data annotations > Default conventions

</details>

<details>

<summary>6. Compare <code>Data annotations</code> and <code>Fluent API</code> in EF Core. Describe main Pros & Cons.</summary>

>#### Answer:

>##### Attributes:
>###### Pros:
>1) Attributes are applied directly to the domain model, so it is easy to see how the model is configured just by examining the class files;
>
>2) Some attributes, such as Required and StringLength are leveraged by client frameworks such as ASP.NET MVC to provide UI-based validation based on the specified configuration;

>###### Cons:
>1) Data Annotation attributes can only provide a subset of configuration options. It may also be necessary to use the Fluent API to provide some configuration which will result in configuration being made in more than one place.

>##### Fluent API link:
>###### Pros:
>1) The Fluent API provides greater scope for configuration than attributes;
>
>2) Configuration can be located in one place, away from the model classes.

>###### Cons:
>Really, there aren't any.

</details>

<details>
<summary>7. How can we set Key for the model? What is the default naming convention for key in EF core? How can we set Composite Key for model?</summary>

>#### Answer:
>EF core has two ways to set primary key to a model (Data Annotation Attribute and Fluent Api). In order to set key using Data Annotation Attribute, we need to add `[Key]` attribute to the property. Also we can set key using Fluent Api, we should use function `HasKey()` with property as parameter. By default, the key is called `Id` or `[class_name] Id`. A composite key can only be created using the Fluent API. In order to create composite key we need to use function `HasKey` with following parameter: `HasKey(o => new { o.Key1, o.Key2});`

</details>

<details>
<summary>8. How can we ignore the entity and property in EF core?</summary>

>#### Answer:
>We can use Data Annotations to exclude a model. We should use attribute `[NotMapped]` to the model. Also can use Data Annotations to exclude a property from the model. We should use attribute `[NotMapped]`. In order to ignore property, we can also use Fluent Api. This can be done using the function `Ignore()`.

</details>

<details>
<summary>9. How can we map entity and table, property and column, if those names are different?</summary>

>#### Answer:
>You can use Data Annotations to configure the table that a type maps to: `[Table("TableName")]`.
>You can also specify a schema that the table belongs to: `[Table("TableName", Schema = "SchemaName")]`.
>
>Also, you can use the Fluent API to configure the table that a type maps to: `ToTable("TableName")` or `ToTable("TableName", schema: "SchemaName")`.
>
>You can use Data Annotations and Fluent API to configure the column to which a property is mapped:
>* `[Column("ColumnName")]`
>* `HasColumnName("ColumnName")`

</details>

<details>
<summary>10. How data seeding can be accomplished in EF Core?</summary>

>#### Answer:
>There are several ways this can be accomplished in EF Core:
>* Model seed data
>* Manual migration customization
>* Custom initialization logic

</details>

<details>
<summary>11. Task: We have two tables in the database. <code>Book</code> table with <code>BookId</code> key and <code>Content</code> column (nvarchar, null). <code>Tag</code> table with <code>TagId</code> key and <code>Title</code> column (nvarchar, null). We need to create many-to-many relationships for these tables. Please describe, how will be look EF entities with many to many relationship.</summary>

>#### Answer:

```csharp
public class Book
{
    public int BookId { get; set; }
    public string Content { get; set; }

    public List<BookTag> BookTags { get; set; }
}

public class Tag
{
    public int TagId { get; set; }
	public string Title { get; set; }

    public List<BookTag> BoolTags { get; set; }
}

public class BookTag
{
    public int BookId { get; set; }
    public Book Book { get; set; }

    public int TagId { get; set; }
    public Tag Tag { get; set; }
}
```

</details>

### CRUD (EF Core)

<details>
<summary>1. Please describe, what purpose have the following classes? <code>DbContext</code>, <code>DbSet/DbSet&lt;T&gt;</code>, <code>DbContextOptionsBuilder</code>.</summary>

>#### Answer:
>* `DbContext` - define the data context used to interact with the database
>* `DbSet/DbSet<T>` - represent a set of objects that are stored in a database
>* `DbContextOptionsBuilder` - set connection parameters and other options for DBContext

</details>

<details>
<summary>2. What can you tell about change tracking in the EF core?</summary>

>#### Answer:
>Each context instance has a `ChangeTracker` that is responsible for keeping track of changes that need to be written to the database. As you make changes to instances of your entity classes, these changes are recorded in the `ChangeTracker` and then written to the database when you call `SaveChanges`. The database provider is responsible for translating the changes into database-specific operations (for example, INSERT, UPDATE, and DELETE commands for a relational database).

</details>

<details>
<summary>3. How can we run no-tracking queries?</summary>

>#### Answer:
>There are multiple ways to run query as no-tracking:
>* We can swap an individual query to be no-tracking: `context.Blogs.AsNoTracking().ToList();`
>* We can also change the default tracking behavior at the context instance level: `context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;`

</details>

<details>
<summary>4. Can we work with stored procedure, sql function, view, and custom sql requests using EF Core? </summary>

>#### Answer:
>EF Core provides the following methods to execute a sql:
>* `DbSet<TEntity>.FromSql`.
>* `DbContext.Database.ExecuteSqlCommand`

</details>

<details>
<summary>5. What is the cascade deleting? What type of the behaviors we can set for cascade deleting in EF core? What is the difference between them?</summary>

>#### Answer:
> Database characteristic that allows the deletion of a row to automatically trigger the deletion of related rows.
>
>* Cascade - Child/dependent entity should be deleted
>* Restrict - Dependents are unaffected
>* SetNull - The foreign key values in dependent rows should update to NULL

</details>

<details>
<summary>6. What steps must be performed in order to insert, update or delete records into the DB table using EF Core in disconnected scenario?</summary>

>#### Answer:
> 
>1) Attach an entity to **DbContext** with an appropriate EntityState e.g. Added, Modified, or Deleted;
>
>2) Call `SaveChanges()` method.
>
>The following example demonstrates inserting a new record into the database using the above steps:
```csharp
    //Disconnected entity
    var std = new Student(){ Name = "Bill" };

    using (var context = new SchoolContext())
    {
        //1. Attach an entity to context with Added EntityState
        context.Add<Student>(std);
        
        //or the followings are also valid
        // context.Students.Add(std);
        // context.Entry<Student>(std).State = EntityState.Added;
        // context.Attach<Student>(std);
                    
        //2. Calling SaveChanges to insert a new record into Students table
        context.SaveChanges();
    }
```

</details>

<details>
<summary>7. What <code>DbContext</code> and <code>DbSet</code> methods are provided in EF Core for attaching disconnected entities with Added EntityState, which in turn will execute INSERT statements in the database? Describe each of them.</summary>

>#### Answer:
> 
>1) **DbContext.Attach / DbSet.Attach** : Attach an entity to DbContext. Set Unchanged state for an entity whose Key property has a value and Added state for an entity whose Key property is empty or the default value of data type;
>
>2) **DbContext.Add / DbSet.Add** : Attach an entity to DbContext with Added state;
> 
>3) **DbContext.AddRange / DbSet.AddRange** : Attach a collection of entities to DbContext with Added state;
>
>4) **DbContext.Entry / -** : Gets an `EntityEntry` for the specified entity which provides access to change tracking information and operations;
> 
>5) **DbContext.AddAsync / DbSet.AddAsync** : Asynchronous method for attaching an entity to DbContext with Added state and start tracking it if not. Data will be inserted into the database when SaveChangesAsync() is called;
>
>6) **DbContext.AddRangeAsync / DbSet.AddRangeAsync** : Asynchronous method for attaching multiple entities to DbContext with Added state in one go and start tracking them if not. Data will be inserted into the database when SaveChangesAsync() is called.

</details>

<details>
<summary>8. Explain why <code>DbContext.Attach()</code> and <code>DbSet.Attach()</code> methods need and how they work.</summary>

>#### Answer:
>The `DbContext.Attach()` and `DbSet.Attach()` methods attach the specified disconnected entity graph to DbContext and start tracking it. Set Unchanged state for an entity whose Key property has a value and Added state for an entity whose Key property is empty or the default value of data type. They return an instance of EntityEntry, which is used to assign the appropriate EntityState.

>The following example demonstrates the behaviour of the `DbContext.Attach()` method on the EntityState of each entity in a graph.
```csharp
    public static void Main()
    {
        var stud = new Student() // Root entity (empty key)
        {
            Name = "Bill",
            Address = new StudentAddress() // Child entity (with key value)
            {
                StudentAddressId = 1,
                City = "Seattle",
                Country = "USA"
            },
            StudentCourses = new List<StudentCourse>() 
            {
                new StudentCourse(){ Course = new Course(){ CourseName = "Machine Language" } }, // Child entity (empty key)
                new StudentCourse(){ Course = new Course(){  CourseId = 2 } } // Child entity (with key value)
            }
        };

        var context = new SchoolContext();
        context.Attach(stud).State = EntityState.Added;  

        DisplayStates(context.ChangeTracker.Entries());
    }

    private static void DisplayStates(IEnumerable<EntityEntry> entries)
    {
        foreach (var entry in entries)
        {
            Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
        }
    }
```
>Output: 
> * Entity: Student, State: Added
> * Entity: StudentAddress, State: Unchanged
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Added
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Unchanged
>
>The `Attach()` method sets Added **EntityState** to the root entity (in this case **Student**) irrespective of whether it contains the Key value or not. If a child entity contains the key value, then it will be marked as Unchanged, otherwise it will be marked as Added. The output of the above example shows that the **Student** entity has Added **EntityState**, the child entities with non-empty key values have Unchanged **EntityState** and the ones with empty key values have Added state.

</details>

<details>
<summary>9. Explain why <code>DbContext.Add()</code> and <code>DbSet.Add()</code> methods need and how they work.</summary>

>#### Answer:
>The `DbContext.Add()` and `DbSet.Add()` methods attach an entity graph to a context and set Added EntityState to a root and child entities, irrespective of whether they have key values or not.

```csharp
    public static void Main()
    {
        var student = new Student() // Root entity (with key value)
        {
            StudentId = 1,
            Name = "Bill",
            Address = new StudentAddress() // Child entity (with key value)
            {
                StudentAddressId = 1,
                City = "Seattle",
                Country = "USA"
            },
            StudentCourses = new List<StudentCourse>() 
            {
                new StudentCourse(){ Course = new Course(){ CourseName = "Machine Language" } }, // Child entity (empty key)
                new StudentCourse(){ Course = new Course(){ CourseId = 2 } } // Child entity (with key value)
            }
        };

        var context = new SchoolContext();
        context.Students.Add(student);

        DisplayStates(context.ChangeTracker.Entries());
    }

    private static void DisplayStates(IEnumerable<EntityEntry> entries)
    {
        foreach (var entry in entries)
        {
            Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
        }
    }
```
>Output: 
> * Entity: Student, State: Added
> * Entity: StudentAddress, State: Added
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Added
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Added

</details>

<details>
<summary>10. Explain why <code>DbContext.Update()</code> and <code>DbSet.Update()</code> methods need and how they work.</summary>

>#### Answer:
>The `DbContext.Update()` and `DbSet.Update()` methods attach an entity graph to a context and set the EntityState of each entity in a graph depending on whether it contains a key property value or not.

>In the below example, the `Update()` method applies the Modified state to the entities which contain non-empty key property values and the Added state to those which contain empty or default CLR key values, irrespective of whether they are a root entity or a child entity.

```csharp
    public static void Main()
    {
        var student = new Student() // Root entity (with key value)
        {
            StudentId = 1,
            Name = "Bill",
            Address = new StudentAddress() // Child entity (with key value)
            {
                StudentAddressId = 1,
                City = "Seattle",
                Country = "USA"
            },
            StudentCourses = new List<StudentCourse>() 
            {
                new StudentCourse(){ Course = new Course(){ CourseName = "Machine Language" } }, // Child entity (empty key)
                new StudentCourse(){ Course = new Course(){ CourseId = 2 } } // Child entity (with key value)
            }
        };

        var context = new SchoolContext();
        context.Update(student);

        DisplayStates(context.ChangeTracker.Entries());
    }

    private static void DisplayStates(IEnumerable<EntityEntry> entries)
    {
        foreach (var entry in entries)
        {
            Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
        }
    }
```

>Output: 
> * Entity: Student, State: Modified
> * Entity: StudentAddress, State: Modified
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Added
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Modified

</details>

<details>
<summary>11. Explain why <code>DbContext.Remove()</code> and <code>DbSet.Remove()</code> methods need and how they work.</summary>

>#### Answer:
>The `DbContext.Remove()` and `DbSet.Remove()` methods set the Deleted EntityState to the root entity.

```csharp
    public static void Main()
    {
        var student = new Student() // Root entity (with key value)
        {
            StudentId = 1,
            Name = "Bill",
            Address = new StudentAddress() // Child entity (with key value)
            {
                StudentAddressId = 1,
                City = "Seattle",
                Country = "USA"
            },
            StudentCourses = new List<StudentCourse>() 
            {
                new StudentCourse(){ Course = new Course(){ CourseName = "Machine Language" } }, // Child entity (empty key)
                new StudentCourse(){ Course = new Course(){ CourseId = 2 } } // Child entity (with key value)
            }
        };

        var context = new SchoolContext();
        context.Remove(student);

        DisplayStates(context.ChangeTracker.Entries());
    }

    private static void DisplayStates(IEnumerable<EntityEntry> entries)
    {
        foreach (var entry in entries)
        {
            Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
        }
    }
```

>Output: 
> * Entity: Student, State: Deleted
> * Entity: StudentAddress, State: Unchanged
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Added
> * Entity: StudentCourse, State: Added
> * Entity: Course, State: Unchanged

</details>

<details>
<summary>12. What are Disconnected Entities in EF Core?</summary>

>#### Answer:
>  Entities that are not being tracked by a context are known as ‘disconnected’ entities.

</details>

<details>
<summary>13. What is the <code>ChangeTracker</code> class in EF Core is responsible for?</summary>

>#### Answer:
>  **ChangeTracker** class in **Microsoft.EntityFrameworkCore.ChangeTracking** namespace is responsible of tracking the state of each entity retrieved using the same DbContext instance. It is not intended to use it directly in your application code because it may change in future versions. However, you can use some methods for tracking purpose.

</details>

<details>
<summary>14. When the <code>ChangeTracker</code> class starts/finishes tracking of all the entities in EF Core?</summary>

>#### Answer:
>  The **ChangeTracker** class in Entity Framework Core starts tracking of all the entities as soon as it is retrieved using DbContext, until they go out of its scope. EF keeps track of all the changes applied to all the entities and their properties, so that it can build and execute appropriate DML statements to the underlying data source.

</details>

<details>
<summary>15. How I can understand that <code>DbContext</code> entity is loaded and change tracking begins?</summary>

>#### Answer:
>  An entity is loaded as a result of a being returned from a query or by being introduced to the context through one of the following methods of the **DbContext**:
>
>1) Entry();
>
>2) Add();
>
>3) Attach();
>
>4) Update();
>
>5) Remove();
>
>or by having its **State** property set on the entity entry returned by calling the context's Entry method.
</details>

<details>
<summary>16. Why <code>ChangeTracker.TrackGraph()</code> method was introduced in EF Core and how it works?</summary>

>#### Answer:
>The `ChangeTracker.TrackGraph()` method was introduced in Entity Framework Core to track the entire entity graph and set custom entity states to each entity in a graph.
>
>Signature: `public virtual void TrackGraph(object rootEntity, Action<EntityEntryGraphNode> callback)`
>
>The `ChangeTracker.TrackGraph()` method begins tracking an entity and any entities that are reachable by traversing it's navigation properties. The specified callback is called for each discovered entity and an appropriate **EntityState** must be set for each entity. The callback function allows us to implement a custom logic to set the appropriate state. If no state is set, the entity remains untracked.

</details>

<details>
<summary>17. List all possible States of context entities in EF Core.</summary>

>#### Answer:
>
>1) Added;
>
>2) Modified;
>
>3) Deleted;
>
>4) Unchanged;
>
>5) Detached.
>
</details>

<details>
<summary>18. Look at the code below and say what State will be in the output and why.</summary>

>**Source Code:**
```csharp
public static void Main()
{
    using (var context = new SchoolContext())
    {
        // retrieve entity
        var student = context.Students.First();
        DisplayStates(context.ChangeTracker.Entries());
    }
}

private static void DisplayStates(IEnumerable<EntityEntry> entries)
{
    foreach (var entry in entries)
    {
        Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
    }
}
```

>#### Answer:
>All the entities retrieved using direct SQL query or LINQ-to-Entities queries will have the `Unchanged` state.
>
>Output: Entity: Student, State: Unchanged.

</details>

<details>
<summary>19. Look at the code below and say what State will be in the output and why.</summary>

>**Source Code:**
```csharp
public static void Main()
{
    using (var context = new SchoolContext())
    {              
        context.Add(new Student() { FirstName = "Bill", LastName = "Gates" });
        
        DisplayStates(context.ChangeTracker.Entries());
    }
}

private static void DisplayStates(IEnumerable<EntityEntry> entries)
{
    foreach (var entry in entries)
    {
        Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
    }
}
```

>#### Answer:
>All the new entities without key property value, added in the **DbContext** using the **Add()** or **Update()** method will be marked as `Added`.
>
>Output: Entity: Student, State: Added.

</details>

<details>
<summary>20. Look at the code below and say what State will be in the output and why.</summary>

>**Source Code:**
```csharp
public static void Main()
{
    using (var context = new SchoolContext())
    {
        var student = context.Students.First();
        student.LastName = "LastName changed";
                
        DisplayStates(context.ChangeTracker.Entries());
    }
}

private static void DisplayStates(IEnumerable<EntityEntry> entries)
{
    foreach (var entry in entries)
    {
        Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
    }
}
```

>#### Answer:
>If the value of any property of an entity is changed in the scope of the **DbContext**, then it will be marked as `Modified` state.
>
>Output: Entity: Student, State: Modified.

</details>

<details>
<summary>21. Look at the code below and say what State will be in the output and why.</summary>

>**Source Code:**
```csharp
public static void Main()
{
    using (var context = new SchoolContext())
    {
        var student = context.Students.First();
        context.Students.Remove(student);
        
        DisplayStates(context.ChangeTracker.Entries());
    }
}

private static void DisplayStates(IEnumerable<EntityEntry> entries)
{
    foreach (var entry in entries)
    {
        Console.WriteLine($"Entity: {entry.Entity.GetType().Name}, State: {entry.State.ToString()} ");
    }
}
```

>#### Answer:
>If any entity is removed from the **DbContext** using the **DbContext.Remove** or **DbSet.Remove method**, then it will be marked as `Deleted`.
>
>Output: Entity: Student, State: Deleted.

</details>

<details>
<summary>22. Look at the code below and say what State will be in the output and why.</summary>

>**Source Code:**
```csharp
public static void Main()
{
    var disconnectedEntity = new Student() { StudentId = 1, Name = "Bill" };

    using (var context = new SchoolContext())
    {              
        Console.Write(context.Entry(disconnectedEntity).State);
    }
}
```

>#### Answer:
>All the entities which were created or retrieved out of the scope of the current **DbContext** instance, will have the `Detached` state. They are also called disconnected entities and are not being tracked by an existing **DbContext** instance.
>
>Output: Detached.

</details>

### Migrations

<details>
<summary>1. What are EF Core migrations?</summary>

>#### Answer:
> EF Core migrations are a set of commands which you can execute in NuGet Package Manager Console or in dotnet Command Line Interface (CLI).

</details>

<details>
<summary>2. How to add/remove EF Core migration using NuGet package manager console?</summary>

>#### Answer:

>##### Create:
>To create a new migration use `Add-Migration` command in Package Manager Console.
>
>Syntax: Add-Migration [-Name] &lt;String&gt; [-OutputDir &lt;String&gt;] [-Context &lt;String&gt;] [-Project &lt;String&gt;] 
                    [-StartupProject &lt;String&gt;] [&lt;CommonParameters&gt;]
>
>This will create three files in the **Migrations** folder of your project:
>
>1) **&lt;timestamp&gt;_&lt;Migration Name&gt;.cs**: The main migration file which includes migration operations in the Up() and Down() methods. The Up() method includes the code for creating DB objects and Down() method includes code for removing DB objects;
>2) **&lt;timestamp&gt;_&lt;Migration Name&gt;.Designer.cs**: The migrations metadata file which contains information used by EF Core;
>3) **&lt;contextclassname&gt;ModelSnapshot.cs**: A snapshot of your current model. This is used to determine what changed when creating the next migration.

>##### Remove:
>To remove the migration use `Remove-Migration` command in Package Manager Console.
>
>Syntax: Remove-Migration [-Force] [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] 
                    [&lt;CommonParameters&gt;]

</details>

<details>
<summary>3. How to add/remove EF Core migration using Command Line Interface?</summary>

>#### Answer:

>##### Create:
>To create a new migration use `dotnet ef migrations add` command in Command Line Interface.
>
>Usage: dotnet ef migrations add [arguments] [options]
>
>This will create three files in the **Migrations** folder of your project:
>
>1) **&lt;timestamp&gt;_&lt;Migration Name&gt;.cs**: The main migration file which includes migration operations in the Up() and Down() methods. The Up() method includes the code for creating DB objects and Down() method includes code for removing DB objects;
>2) **&lt;timestamp&gt;_&lt;Migration Name&gt;.Designer.cs**: The migrations metadata file which contains information used by EF Core;
>3) **&lt;contextclassname&gt;ModelSnapshot.cs**: A snapshot of your current model. This is used to determine what changed when creating the next migration.

>##### Remove:
>To remove the migration use `dotnet ef migrations remove` command in Command Line Interface.
>
>Usage: dotnet ef migrations remove [options]

</details>

<details>
<summary>4. How to create/update/remove database in EF Core using NuGet package manager console?</summary>

>#### Answer:

>##### Create or Update:
>To create or update the database schema use `Update-Database` command in Package Manager Console. The **Update** command will create the database based on the context and domain classes and the migration snapshot, which is created using the `add-migration` (PMC) or `add` (CLI) command.
>
>Syntax: Update-Database [[-Migration] &lt;String&gt;] [-Context &lt;String&gt;] [-Project &lt;String&gt;] 
                        [-StartupProject &lt;String&gt;] [&lt;CommonParameters&gt;]

>##### Remove:
>To remove the database use `Drop-Database` command in Package Manager Console.
>
>Syntax: Drop-Database [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] 
                    [-WhatIf] [-Confirm] [&lt;CommonParameters&gt;]

</details>

<details>
<summary>5. How to create/update/remove database in EF Core using Command Line Interface?</summary>

>#### Answer:

>##### Create or Update:
>To create or update the database schema use `dotnet ef database update` command in Command Line Interface. The **Update** command will create the database based on the context and domain classes and the migration snapshot, which is created using the `add-migration` (PMC) or `add` (CLI) command.
>
>Usage: dotnet ef database update [arguments] [options]

>##### Remove:
>To remove the database use `dotnet ef database drop` command in Command Line Interface.
>
>Usage: dotnet ef database drop [options]

</details>

<details>
<summary>6. I want to generate a migration SQL script in EF Core. How can I do this?</summary>

>#### Answer:

>##### Package Manager Console:
>To generate a migration SQL script use `Script-Migration` command in Package Manager Console.
>
>Syntax: Script-Migration [-From] &lt;String&gt; [-To] &lt;String&gt; [-Idempotent] [-Output &lt;String&gt;] 
                        [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] 
                        [&lt;CommonParameters&gt;]

>##### Command Line Interface:
>To generate a migration SQL script use `dotnet ef migrations script` command in Command Line Interface.
>
>Usage: dotnet ef migrations script [arguments] [options]

</details>