# Advanced Level Questions

## Table of Contents

### LINQ

<details>
<summary>1. When trying to decide between using the Entity Framework and LINQ to SQL as an ORM, what's the difference?</summary>

>#### Answer:
>* **LINQ to SQL** only supports 1 to 1 mapping of database tables, views, sprocs and functions available in Microsoft SQL Server. It's a great API to use for quick data access construction to relatively well designed SQL Server databases. LINQ2SQL was first released with C# 3.0 and .Net Framework 3.5.
>* **LINQ to Entities** (ADO.Net Entity Framework) is an ORM (Object Relational Mapper) API which allows for a broad definition of object domain models and their relationships to many different ADO.Net data providers. As such, you can mix and match a number of different database vendors, application servers or protocols to design an aggregated mash-up of objects which are constructed from a variety of tables, sources, services, etc. ADO.Net Framework was released with the .Net Framework 3.5 SP1.

</details>

<details>
<summary>2. Could you explain how exactly does deferred execution work in LINQ?</code></summary>

>#### Answer:
When you create a LINQ query on an IQueryable<T> object, LINQ builds an Expression Tree that stores all the procedures to be executed on the queried collection. When you call an aggregation method, LINQ executes the Expression Tree and returns the query result. Expression tree is executed every time you call an aggregation method, so if the initial data is changed between the calls, the result may differ.

</details>

### Database modelling with Code First (EF Core)

<details>
<summary>1. What ways in which object-oriented inheritance can be represented in a database do you know? Describe each of them.</summary>

>#### Answer:
>There are 3 ways in which object-oriented inheritance can be represented in a database:
>
>1) **Table Per Hierarchy (TPH)** : One table is used to represent all classes in the hierarchy. A "discriminator" column is used to discriminate between differing types. The table takes the name of the base class or its associated DbSet property by default. In previous versions of Entity Framework, TPH was the default mapping pattern for inheritance. Entity Framework Core currently only implements the TPH pattern.
>
>2) **Table Per Type (TPT)** : A separate table is used to represent each type in the inheritance chain, including abstract types. Tables that represent derived types are related to their base type via foreign keys.
>
>3) **Table Per Concrete Type (TPC)** : A separate table is used to represent each concrete type in the inheritance chain. Properties in any abstract base type are generated as fields in each concrete type's table. There is no relationship between differing types.

</details>

<details>
<summary>2. What inheritance approaches are supported in EF Core? Describe each of them.</summary>

>#### Answer:
>There is only one pattern is supported now in EF Core:
>
>**Table Per Hierarchy (TPH)** : One table is used to represent all classes in the hierarchy. A "discriminator" column is used to discriminate between differing types. The table takes the name of the base class or its associated DbSet property by default. In previous versions of Entity Framework, TPH was the default mapping pattern for inheritance.
>
>The TPT pattern is currently being considered for inclusion but no date has been decided yet.
>
>The TPC pattern is currently on the backlog, which means that it is being considered for inclusion as a feature, but no date has been set as yet.

</details>

<details>
<summary>3. How Table Per Hierarchy Inheritance work in EF Core?</summary>

>#### Answer:
>Entity Framework Core will represent an object-oriented hierarchy in a single table that takes the name of the base class and includes a "discriminator" column to identify the specific type for each row. EF Core will only include types that are explicitly included in the model and will only implement the discriminator column if two or more types (including the base type) have a DbSet configured for them.

</details>

<details>
<summary>4. What limitations of model does EF Core has for data seeding process?</summary>

>#### Answer:
> Limitations of model seed data:
>* The primary key value needs to be specified even if it's usually generated by the database. It will be used to detect data changes between migrations.
>* Previously seeded data will be removed if the primary key is changed in any way.

</details>

### CRUD (EF Core)

<details>
<summary>1. How to enable client side evaluation in EF Core?</summary>

>#### Answer:
>You can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async). By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory. Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database. Depending on the particular usage, you should evaluate which method is more useful for the case.
>
```csharp
var specialCustomers =
  context.Customers
    .Where(c => c.Name.StartsWith(n))
    .AsEnumerable() // Switch to LINQ to Objects to client-eval the rest of the query
    .Where(c => IsSpecialCustomer(c));
```

</details>

<details>
<summary>2. What is the profit of using no-tracking queries in EF Core?</summary>

>#### Answer:
>No tracking query executes quickly because there is no need to setup change tracking information. It is useful when the results are used in a read-only scenario.

</details>

<details>
<summary>3. I want to use no-tracking queries in EF Core. How can I reach this?</summary>

>#### Answer:
>You can convert a query to a no-tracking query by using **AsNoTracking()** method.
>
>The **AsNoTracking()** method returns a new query where the change tracker will not track any of the entities that are returned. If the entity instances are modified, this will not be detected by the change tracker, and **SaveChanges()** will not persist those changes to the database.
>
```csharp
    using (var context = new MyContext())
    {
        var customers = context.Customers
            .AsNoTracking().ToList();
    }
```
>
>You can also change the default tracking behavior at the context instance level.
>
```csharp
    using (var context = new MyContext())
    {
        context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
        var customers = context.Customers.ToList();
    }
```
</details>
